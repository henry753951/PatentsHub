邏輯請從UI流程規劃，並且最適合的寫法 ps:我寫的是nuxt3，但不用幫我寫 UI，僅需參考我其他的 composable 就好()，下方為範例。幫我寫 usePatentFundings
model FundingUnit {
  FundingUnitID           Int                               @id @default(autoincrement())
  Name                    String
  fundingUnits            PatentFundingUnit[]
  fundingRecords          PatentFundingRecord[]
  contributions           PatentFundingExportContribution[] // 新增的分帳關聯
  FundingPlanAllocation   FundingPlanAllocation?            @relation(fields: [FundingPlanAllocationID], references: [FundingPlanAllocationID])
  FundingPlanAllocationID Int?
}

// [Patent root node]
model FundingPlan {
  FundingPlanID    Int                     @id @default(autoincrement())
  PlanType         Int
  Name             String
  fundings         PatentFunding[]
  plannAllocations FundingPlanAllocation[]
}

// FundingPlan root node > FundingPlanAllocations[]
model FundingPlanAllocation {
  FundingPlanAllocationID Int               @id @default(autoincrement())
  Percentage              Decimal
  TargetID                Int
  target                  FundingPlanTarget @relation(fields: [TargetID], references: [TargetID])
  FundingPlanID           Int
  fundingPlan             FundingPlan       @relation(fields: [FundingPlanID], references: [FundingPlanID], onDelete: Cascade, onUpdate: Cascade)
  fundingUnits            FundingUnit[]
}

// FundingPlan root node > FundingPlanTargets[]
model FundingPlanTarget {
  TargetID Int                     @id @default(autoincrement())
  Name     String
  targets  FundingPlanAllocation[]

  PatentFundingExportInternalAllocation PatentFundingExportInternalAllocation[]
}

// [PatentFunding root node]
model PatentFunding {
  PatentID          Int                   @id
  patent            Patent                @relation(fields: [PatentID], references: [PatentID], onDelete: Cascade, onUpdate: Cascade)
  FundingPlanPlanID Int
  plan              FundingPlan           @relation(fields: [FundingPlanPlanID], references: [FundingPlanID])
  fundingRecords    PatentFundingRecord[]
  fundingUnits      PatentFundingUnit[]
  fundingExports    PatentFundingExport[]
}

// PatentFunding root node > FundingUnits[]
model PatentFundingUnit {
  ProjectCode   String
  FundingUnitID Int
  fundingUnit   FundingUnit   @relation(fields: [FundingUnitID], references: [FundingUnitID], onDelete: Cascade, onUpdate: Cascade)
  PatentID      Int
  patentFunding PatentFunding @relation(fields: [PatentID], references: [PatentID], onDelete: Cascade, onUpdate: Cascade)

  @@id([PatentID, FundingUnitID])
}

// PatentFunding root node > FundingRecords[]
model PatentFundingRecord {
  FundingRecordID       Int                  @id @default(autoincrement())
  Amount                Float
  Date                  DateTime
  PatentFundingPatentID Int
  patentFunding         PatentFunding        @relation(fields: [PatentFundingPatentID], references: [PatentID])
  ExportID              Int?
  fundingExport         PatentFundingExport? @relation(fields: [ExportID], references: [ExportID])
  canFundingBy          FundingUnit[] // 可選擇的資助單位，若為空則全額自行資助
}

// [Export root node]
model PatentFundingExport {
  ExportID            Int                                     @id @default(autoincrement())
  ExportDate          DateTime
  PatentID            Int
  patentFunding       PatentFunding                           @relation(fields: [PatentID], references: [PatentID])
  exportRecords       PatentFundingRecord[] // 已導出的紀錄
  // 出帳資訊
  contributions       PatentFundingExportContribution[] // 各資助單位的補助金額
  internalAllocations PatentFundingExportInternalAllocation[] // 校內分配金額
}

// Export root node > Contributions[]
model PatentFundingExportContribution {
  ContributionID Int                 @id @default(autoincrement())
  ExportID       Int
  FundingUnitID  Int?
  Amount         Float
  export         PatentFundingExport @relation(fields: [ExportID], references: [ExportID], onDelete: Cascade, onUpdate: Cascade)
  fundingUnit    FundingUnit?        @relation(fields: [FundingUnitID], references: [FundingUnitID], onDelete: Cascade, onUpdate: Cascade)

  @@index([ExportID])
}

// Export root node > InternalAllocation[]
model PatentFundingExportInternalAllocation {
  InternalContributionID Int                 @id @default(autoincrement())
  Amount                 Decimal
  PlaneTargetID          Int
  planeTarget            FundingPlanTarget   @relation(fields: [PlaneTargetID], references: [TargetID])
  ExportID               Int
  export                 PatentFundingExport @relation(fields: [ExportID], references: [ExportID], onDelete: Cascade, onUpdate: Cascade)

  @@index([ExportID])
}

假設目前
FundingUnits : [
國科會,
科技部
]

FundingPlans : [
A : {
校方 55%
發明人 40%
院系所 5%
}
B : {
校方 35%
發明人 60%
院系所 5%
}
C : {
校方 0%
發明人 95%
院系所 5%
}
]


```
import { useNow } from "@vueuse/core";

export const usePatentMaintenances = (patentService: {
   data: Ref<RouterOutput["data"]["patent"]["getPatent"]>
   refreshCallback?: () => Promise<void>
}) => {
   const now = useNow({ interval: 10 * 1000 });
   const { $trpc } = useNuxtApp();
   const { data: patent, refreshCallback } = patentService;
   const DbMaintenances = computed(() => {
      return patent.value?.maintenances ?? [];
   });

   // ==================================================
   // [Actions]
   // ==================================================

   const addMaintenance = async (maintenance: {
      MaintenanceDate: Date
      ExpireDate: Date
   }) => {
      if (!patent.value) return;
      await $trpc.data.patent.updatePatent.mutate([
         {
            data: {
               maintenances: {
                  create: {
                     MaintenanceDate: maintenance.MaintenanceDate,
                     ExpireDate: maintenance.ExpireDate,
                  },
               },
            },
            patentID: patent.value.PatentID,
         },
      ]);
      if (refreshCallback) await refreshCallback();
   };

   const editMaintenance = async (
      maintenanceID: number,
      maintenance: {
         MaintenanceDate: Date
         ExpireDate: Date
      },
   ) => {
      if (!patent.value) return;
      await $trpc.data.patent.updatePatent.mutate([
         {
            data: {
               maintenances: {
                  update: {
                     data: {
                        MaintenanceDate: maintenance.MaintenanceDate,
                        ExpireDate: maintenance.ExpireDate,
                     },
                     where: {
                        MaintenanceID: maintenanceID,
                     },
                  },
               },
            },
            patentID: patent.value.PatentID,
         },
      ]);
      if (refreshCallback) await refreshCallback();
   };

   const deleteMaintenance = async (maintenanceID: number) => {
      if (!patent.value) return;
      await $trpc.data.patent.updatePatent.mutate([
         {
            data: {
               maintenances: {
                  delete: {
                     MaintenanceID: maintenanceID,
                  },
               },
            },
            patentID: patent.value.PatentID,
         },
      ]);
      if (refreshCallback) await refreshCallback();
   };

   // ==================================================
   // [Computed Properties]
   // ==================================================

   const sortedMaintenances = computed(() => {
      return [...DbMaintenances.value].sort(
         (a, b) => a.MaintenanceDate.getTime() - b.MaintenanceDate.getTime(),
      );
   });

   const maintenanceStatus = computed(() => {
      if (DbMaintenances.value.length === 0) return null;

      const earliestMaintenance = sortedMaintenances.value[0];
      const latestMaintenance
         = sortedMaintenances.value[sortedMaintenances.value.length - 1];
      const maintenanceStartDate = earliestMaintenance.MaintenanceDate;
      const latestMaintenanceDate = latestMaintenance.MaintenanceDate;
      const nextMaintenanceDate = latestMaintenance.ExpireDate;
      const _maintenanceSeconds = Math.floor(
         nextMaintenanceDate.getTime() - maintenanceStartDate.getTime(),
      );
      const maintenanceYears = Math.floor(_maintenanceSeconds / 1000 / 60 / 60 / 24 / 365 * 10) / 10;

      return {
         maintenanceStartDate,
         latestMaintenanceDate,
         nextMaintenanceDate,
         maintenanceYears,
         nextMaintenanceLabel:
            now.value > nextMaintenanceDate ? "到期時間" : "下次維護期程",
      };
   });

   return {
      addMaintenance,
      editMaintenance,
      deleteMaintenance,
      maintenances: sortedMaintenances,
      maintenanceStatus,
   };
};
```

 patent.value?.funding?.fundingRecords
 patent.value?.funding?.patentFundingUnits
 (ps patent.value  型態結構為與prisma回傳的都會一樣喔，特別注意與檢查)
- 主要處理 帳務記錄相關 就好  ，FundingUnits 直接 computed 取得就好，不要有新增的邏輯
- await $trpc.data.patent.updatePatent.mutate() 資料庫處理一律用這個

# 新增流程如下
我按下新增帳目，輸入帳款名稱、金額、描述，在選擇這個Record可以被那些單位資助(多選)

# 出帳流程
可以選擇要出帳的項目(只能選 fundingExport 是空的)
然後可以輸入每個 FundingUnit 能資助的金額，然後會去按照每個選擇的 record 是否能被資助
然後進行分配。
分配方式就是最大化用完資助的金額 (這邊的邏輯請而外隔離，我可能會要變動分配邏輯)
假設分配完已經不夠了，就將*剩餘不夠支應的款項*及*小數點多出來的*，移交到校內帳務處理(按照FundingPlan 處理)
會輸出下面兩個資訊 :
## 資助單位帳務
資助單位帳務 :  [{
    原金額: number,
    資助單位資助資訊: [
     {xx單位 支應 多少錢}
    ],
    資助後剩餘的錢 : number
    record : PatentFundingRecord
}]

## 校內帳務
這個請按照  patent.value?.funding?.plan?
去看看屬於哪一種類別 並按照該類別分配比重去做計算，算出各方的預設金額(可以調整)，下方為舉例以及輸出
假設使用 A 版
校內帳務: {
    records: typeof 資助單位帳務, // 這邊會篩選上面的 資助單位帳務 資助後剩餘的錢 不為 0 的
    plan: FundingPlan,
    results:[
校方 55% 金額,
發明人 40%金額,
院系所 5%金額,
     ]
}

所以請注意囉，導出的介面是會出現，各方資助的金額與比例，並且還可以做調整，所以也要有調整的 ref ，以及總校內負責金額的 computed 出來 (這樣介面可以呈現 我拉百分比或是直接調整金額，可以檢查是否分配完畢)


所以整個 composable 要輸出的會有
紀錄:{
  actions: { 方法 },
  紀錄的 array (computed)
},
導出 : {
   actions: { 計算資助單位帳務，計算校內帳務，導出，刪除，編輯 },
   導出的紀錄 (computed),
}

---
其中
計算資助單位帳務 function (傳入個資助單位的資助金額)
回傳 {
    資助單位帳務(不用VUE響應)
}

計算校內帳務 function (傳入更新過的資助單位帳務)
回傳 {
    校內帳務 (不用VUE響應)
}

導出 function (傳入 最後的資助單位帳務 、校內帳務)
並更新資料庫，最終完成新增 PatentFundingExport 這筆資料的所有項目


如果我有那裡規劃的不適合 或是有更好的方式 也可以建議並幫我做修改 感謝您